load("my_returns.rda")
corr = cor(my_returns[,2*(1:n_assets)])*100
n_assets = (dim(my_returns)[2]%/%2)
corr = cor(my_returns[,2*(1:n_assets)])*100
View(corr)
a <- my_returns
setwd("C:/Users/matte/Desktop/MasterThesis-vianello/R_code")
load("returns.rda")
View(my_returns)
View(a)
b = my_data
setwd("C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code")
load("my_data.rda")
View(my_data)
View(b)
load("my_returns.rda")
# latest = max(dates)
latest = "2028-02-02"
w = 46 # rolling window in months
step = 1 # moving step in months
d = as.Date(mondate(latest, timeunits = )-step,origin="1899-12-30")
beg_times = as.Date(mondate(latest)-w)
end_times = latest
n_assets = (dim(my_returns)[2]%/%2)
attach(my_returns)
earliest = "2016-01-01"
dates = as.Date(btc_date, origin="1899-12-30")
earliest = "2016-01-01"
# latest = max(dates)
latest = "2028-02-02"
w = 46 # rolling window in months
step = 1 # moving step in months
d = as.Date(mondate(latest, timeunits = )-step,origin="1899-12-30")
beg_times = as.Date(mondate(latest)-w)
end_times = latest
n_assets = (dim(my_returns)[2]%/%2)
idx = which(dates >= beg_times & dates<=end_times)
correlations = cor(btc[idx],my_returns[idx,2*(1:n_assets)])
returns_2015 = my_returns[idx,2*(1:n_assets)]
corr2015 = cor(returns_2015)*100
corr_tot = cor(my_returns[idx,2*(1:n_assets)])*100
View(corr_tot)
idx
beg_times
View(my_returns)
beg_times = "2016-01-04"
end_times
# latest = max(dates)
latest = "2018-02-02"
end_times = latest
n_assets = (dim(my_returns)[2]%/%2)
idx = which(dates >= beg_times & dates<=end_times)
correlations = cor(btc[idx],my_returns[idx,2*(1:n_assets)])
returns_2015 = my_returns[idx,2*(1:n_assets)]
corr2015 = cor(returns_2015)*100
corr_tot = cor(my_returns[idx,2*(1:n_assets)])*100
View(corr_tot)
setwd("C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code")
library(mondate)
library(readxl)
crypto_returns_m = read_excel('C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/dataset_completo.xlsx', sheet = 'rendimenti')
my_data_final = read_excel('C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/dataset_completo.xlsx', sheet = 'rendimenti')
save(my_data_final, file = "C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/my_data_final.rda")
my_data_final = read_excel('C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/dataset_completo.xlsx', sheet = 'prezzi')
save(my_data_final, file = "C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/my_data_final.rda")
my_returns_final = read_excel('C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/dataset_completo.xlsx', sheet = 'rendimenti')
save(my_returns_final, file = "C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/my_returns_final.rda")
attach(my_returns_final)
dates = as.Date(btc_date, origin="1899-12-30")
n_assets = (dim(my_returns_final)[2]%/%2)
idx = which(dates >= beg_times & dates<=end_times)
corr_final = cor(my_returns_final[idx,2*(1:n_assets)])*100
View(corr_final)
View(corr_final)
load("my_returns.rda")
load("my_data.rda")
my_returns
head(my_returns)
head(my_returns_final)
my_data
View(my_data)
View(my_data_final)
View(my_returns)
View(my_returns_final)
library(mondate)
setwd("C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code")
load("my_data_final.rda")
load("my_returns_final.rda")
attach(my_returns_final)
dates = as.Date(btc_date, origin="1899-12-30")
earliest = "2016-01-01"
# latest = max(dates)
latest = "2018-02-02"
w = 46 # rolling window in months
dates
# latest = max(dates)
latest = "2020-02-02"
w = 46 # rolling window in months
step = 1 # moving step in months
d = as.Date(mondate(latest, timeunits = )-step,origin="1899-12-30")
beg_times = as.Date(mondate(latest)-w)
end_times = latest
beg_times = "2016-01-04"
n_assets = (dim(my_returns_final)[2]%/%2)
idx = which(dates >= beg_times & dates<=end_times)
corr_final = cor(my_returns_final[idx,2*(1:n_assets)])*100
View(corr_final)
setwd("C:/Users/matte/Desktop/MasterThesis-vianello/R_code")
source("MarkowitzMeanVariancePortfolio.R")
my_returns = my_returns_final
my_data = my_data_final
##########################################
##### compute efficient frontier #########
##########################################
library(pracma)
# attach(my_returns)
source("MarkowitzMeanVariancePortfolio.R")
# Number of samples to consider from latest {max is dim(my_returns)[1]}
N_samples = dim(my_returns)[1]
# Number of assets
N_assets = dim(my_returns)[2]/2 -1 # -1 to exclude VIX from our analysis
# ***** PERCENTAGE RETURNS ******
expected_return_sample = colMeans(exp(my_returns[1:N_samples,2*(1:N_assets)]))^255
SS = cov(exp(my_returns[1:N_samples,2*(1:N_assets)]))*255
max_r = 1.5
y_lim = c(1.00,max_r)
# Plots the efficient frontiers, w/ and w/o Bitcoin, w/ and w/o shortselling
eff_front = PlotEfficientFrontier(expected_return_sample, SS, min_r = 1, max_r=max_r,
exclude_btc = T, add_no_short_sell = T, full_plot = F)
expected_return_sample
setwd("C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code")
my_returns_final = read_excel('C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/dataset_completo.xlsx', sheet = 'rendimenti')
library(readxl)
my_returns_final = read_excel('C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/dataset_completo.xlsx', sheet = 'rendimenti')
save(my_returns_final, file = "C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/my_returns_final.rda")
library(readxl)
my_data_final = read_excel('C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/dataset_completo.xlsx', sheet = 'prezzi')
save(my_data_final, file = "C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/my_data_final.rda")
my_returns = my_returns_final
my_data = my_data_final
setwd("C:/Users/matte/Desktop/MasterThesis-vianello/R_code")
source("MarkowitzMeanVariancePortfolio.R")
##########################################
##### compute efficient frontier #########
##########################################
library(pracma)
# attach(my_returns)
source("MarkowitzMeanVariancePortfolio.R")
# Number of samples to consider from latest {max is dim(my_returns)[1]}
N_samples = dim(my_returns)[1]
# Number of assets
N_assets = dim(my_returns)[2]/2 -1 # -1 to exclude VIX from our analysis
# ***** PERCENTAGE RETURNS ******
expected_return_sample = colMeans(exp(my_returns[1:N_samples,2*(1:N_assets)]))^255
SS = cov(exp(my_returns[1:N_samples,2*(1:N_assets)]))*255
max_r = 1.5
y_lim = c(1.00,max_r)
expected_return_sample
my_returns
colnames(my_returns)
a = colnames(my_returns)
a
# Number of assets
nomi = colnames(my_returns)
typeof(nomi)
nomi
# Number of assets
n = dim(my_returns)[2]/2
# Number of assets
n = dim(my_returns[,2*(1:n)])[2]/2
n
n = dim(my_returns)[2]/2
n
nomi = colnames(my_returns[1:N_samples,2*(1:N_assets)])[-c('vix','xrp')]
nomi = colnames(my_returns[1:N_samples,2*(1:N_assets)])-c('vix','xrp')
colnames(my_returns[1:N_samples,2*(1:N_assets)])
my_data_final
my_returns_final
my_data_final
View(my_data_final)
my_returns = my_returns_final
my_data = my_data_final
# Number of samples to consider from latest {max is dim(my_returns)[1]}
N_samples = dim(my_returns)[1]
n = dim(my_returns)[2]/2
nomi = colnames(my_returns[1:N_samples,2*(1:N_assets)])-c('vix','xrp')
colnames(my_returns[1:N_samples,2*(1:N_assets)])
colnames(my_returns[1:N_samples,2*(1:n)])
nomi = colnames(my_returns[1:N_samples,2*(1:n)])-c('vix','xrp')
c('vix','xrp')
nomi = colnames(my_returns[1:N_samples,2*(1:n)])[colnames(my_returns[1:N_samples,2*(1:n)]) != 'vix')
N_assets = dim(my_returns)[2]/2 -1 # -1 to exclude VIX from our analysis
# ***** PERCENTAGE RETURNS ******
expected_return_sample = colMeans(exp(my_returns[1:N_samples,2*(1:N_assets)]))^255
SS = cov(exp(my_returns[1:N_samples,2*(1:N_assets)]))*255
max_r = 1.5
y_lim = c(1.00,max_r)
# Plots the efficient frontiers, w/ and w/o Bitcoin, w/ and w/o shortselling
eff_front = PlotEfficientFrontier(expected_return_sample, SS, min_r = 1, max_r=max_r,
exclude_btc = T, add_no_short_sell = T, full_plot = F)
# dev.copy2pdf(file = "efficient_frontier.pdf", height = 7, width=7 )
# dev.off()
##################### ALLOCATIONS FOR GIVEN VOLATILITY ###################################
# target volatility for which allocation will be computed
vol_target = seq(from = 0.0275,to = 0.12, by = 0.0025)
# initialize result variables
allocations_vol = zeros(length(vol_target), N_assets)
colnames(allocations_vol) = colnames(my_returns[,2*(1:N_assets)])
returns_vol = zeros(length(vol_target),1)
allocations_vol_no_btc = zeros(length(vol_target), N_assets)
colnames(allocations_vol_no_btc) = colnames(my_returns[,2*(1:N_assets)])
returns_vol_no_btc = zeros(length(vol_target),1)
for (i in 1:length(vol_target)) {
allocations_vol[i,] = OptimalAllocation(r=expected_return_sample,S=SS, sd=vol_target[i], no_short_sales=1:N_assets)
returns_vol[i,1] = sum(allocations_vol[i,]*expected_return_sample)
allocations_vol_no_btc[i,2:N_assets] = OptimalAllocation(r=expected_return_sample[2:N_assets],S=SS[2:N_assets,2:N_assets], sd=vol_target[i], no_short_sales=1:(N_assets-1))
returns_vol_no_btc[i,1] = sum(allocations_vol_no_btc[i,]*expected_return_sample)
}
# polish data for small allocation ( allocation of 1e-10 set to zero)
allocations_vol[which(abs(allocations_vol)<1e-10)] = 0
allocations_vol_no_btc[which(abs(allocations_vol_no_btc)<1e-10)] = 0
points(vol_target,returns_vol_no_btc-1,col="orange")
points(vol_target,returns_vol-1,col="green")
# aggregate results for saving to file
res_btc = cbind(returns_vol-1,vol_target, allocations_vol)
colnames(res_btc)[c(1,2)] = c("exp_return","volatility")
res_no_btc = cbind(returns_vol_no_btc-1,vol_target, allocations_vol_no_btc)
colnames(res_no_btc)[c(1,2)] = c("exp_return","volatility")
# # save to file
# write.csv(file = "allocation_on_vol.csv", x = res_btc)
# write.csv(file = "allocation_on_vol_no_btc.csv", x = res_no_btc)
##################### ALLOCATIONS FOR GIVEN RETURNS #####################################
# target return for which allocation will be computed
targets = c(seq(1.025, 1.15, by = 0.005), seq(1.175, 1.8, by=0.025))
# initialize result variables
l=length(targets)
alloc_btc = zeros(l,N_assets)
colnames(alloc_btc)=colnames(my_returns[,2*(1:N_assets)])
sigma_ret_btc = zeros(l,1)
alloc_no_btc = zeros(l,N_assets)
colnames(alloc_no_btc)=colnames(my_returns[,2*(1:N_assets)])
sigma_ret_no_btc = zeros(l,1)
for(i in 1:l){
# print(paste(i, targets[i]))
alloc_btc[i,]= OptimalAllocation(r=expected_return_sample,S=SS, target_return = targets[i], no_short_sales = 1:N_assets)
sigma_ret_btc[i,1] = sqrt( t(alloc_btc[i,]) %*% SS %*%  alloc_btc[i,])
alloc_no_btc[i,2:N_assets]= OptimalAllocation(r=expected_return_sample[2:N_assets], S=SS[2:N_assets,2:N_assets], target_return = targets[i], no_short_sales = 1:(N_assets-1))
sigma_ret_no_btc[i,1] = sqrt( t(alloc_no_btc[i,]) %*% SS %*%  alloc_no_btc[i,])
}
# polish data for small allocation ( allocation of 1e-10 set to zero)
alloc_btc[which(abs(alloc_btc)<1e-10)] = 0
alloc_no_btc[which(abs(alloc_no_btc)<1e-10)] = 0
# aggregate results for saving to file
res2_btc = cbind(targets-1,sigma_ret_btc, alloc_btc)
colnames(res2_btc)[c(1,2)] = c("exp_return","volatility")
res2_no_btc = cbind(targets-1,sigma_ret_no_btc, alloc_no_btc)
colnames(res2_no_btc)[c(1,2)] = c("exp_return","volatility")
# save to file
write.csv(file = "allocation_on_ret.csv", x = res2_btc)
write.csv(file = "allocation_on_ret_no_btc.csv", x = res2_no_btc)
################## Plotting Allocations with R #######################
# ggplot2 library
library(ggplot2)
library(RColorBrewer)
Asset = rep(colnames(alloc_btc), l)
Return = rep(targets, each = N_assets)
Values = drop(matrix(t(alloc_btc), nrow = 1))
colorRampPalette(brewer.pal(9, "Spectral"))(N_assets)
data <- data.frame(Asset,Return,Values)
ggplot(data, aes(x=Return, y=Values, fill=Asset)) +
geom_area(alpha=1 , size=1, colour="black") +
ggtitle("Markowitz Optimal Allocation Without Shortsellling")+
scale_fill_manual(values =colorRampPalette(brewer.pal(9, "Paired"))(N_assets) )
# wiithout btc
maxN = 26
reduced = alloc_no_btc[1:maxN,]
Asset = rep(colnames(reduced), maxN)
Return = rep(targets[1:maxN], each = N_assets)
Values = drop(matrix(t(reduced), nrow = 1))
colorRampPalette(brewer.pal(9, "Spectral"))(N_assets)
data <- data.frame(Asset,Return,Values)
ggplot(data, aes(x=Return, y=Values, fill=Asset)) +
geom_area(alpha=1 , size=1, colour="black") +
ggtitle("Markowitz Optimal Allocation Without Bitcoin")+
scale_fill_manual(values =colorRampPalette(brewer.pal(9, "Paired"))(N_assets) )
nomi = colnames(my_returns[1:N_samples,2*(1:n)])[colnames(my_returns[1:N_samples,2*(1:n)]) != 'vix')
N_assets = dim(my_returns)[2]/2 -1 # -1 to exclude VIX from our analysis
# ***** PERCENTAGE RETURNS ******
expected_return_sample = colMeans(exp(my_returns[1:N_samples,2*(1:N_assets)]))^255
SS = cov(exp(my_returns[1:N_samples,2*(1:N_assets)]))*255
max_r = 1.5
y_lim = c(1.00,max_r)
# Plots the efficient frontiers, w/ and w/o Bitcoin, w/ and w/o shortselling
eff_front = PlotEfficientFrontier(expected_return_sample, SS, min_r = 1, max_r=max_r,
exclude_btc = T, add_no_short_sell = T, full_plot = F)
# dev.copy2pdf(file = "efficient_frontier.pdf", height = 7, width=7 )
# dev.off()
##################### ALLOCATIONS FOR GIVEN VOLATILITY ###################################
# target volatility for which allocation will be computed
vol_target = seq(from = 0.0275,to = 0.12, by = 0.0025)
# initialize result variables
allocations_vol = zeros(length(vol_target), N_assets)
colnames(allocations_vol) = colnames(my_returns[,2*(1:N_assets)])
returns_vol = zeros(length(vol_target),1)
allocations_vol_no_btc = zeros(length(vol_target), N_assets)
colnames(allocations_vol_no_btc) = colnames(my_returns[,2*(1:N_assets)])
returns_vol_no_btc = zeros(length(vol_target),1)
for (i in 1:length(vol_target)) {
allocations_vol[i,] = OptimalAllocation(r=expected_return_sample,S=SS, sd=vol_target[i], no_short_sales=1:N_assets)
returns_vol[i,1] = sum(allocations_vol[i,]*expected_return_sample)
allocations_vol_no_btc[i,2:N_assets] = OptimalAllocation(r=expected_return_sample[2:N_assets],S=SS[2:N_assets,2:N_assets], sd=vol_target[i], no_short_sales=1:(N_assets-1))
returns_vol_no_btc[i,1] = sum(allocations_vol_no_btc[i,]*expected_return_sample)
}
# polish data for small allocation ( allocation of 1e-10 set to zero)
allocations_vol[which(abs(allocations_vol)<1e-10)] = 0
allocations_vol_no_btc[which(abs(allocations_vol_no_btc)<1e-10)] = 0
points(vol_target,returns_vol_no_btc-1,col="orange")
points(vol_target,returns_vol-1,col="green")
# aggregate results for saving to file
res_btc = cbind(returns_vol-1,vol_target, allocations_vol)
colnames(res_btc)[c(1,2)] = c("exp_return","volatility")
res_no_btc = cbind(returns_vol_no_btc-1,vol_target, allocations_vol_no_btc)
colnames(res_no_btc)[c(1,2)] = c("exp_return","volatility")
# # save to file
# write.csv(file = "allocation_on_vol.csv", x = res_btc)
# write.csv(file = "allocation_on_vol_no_btc.csv", x = res_no_btc)
##################### ALLOCATIONS FOR GIVEN RETURNS #####################################
# target return for which allocation will be computed
targets = c(seq(1.025, 1.15, by = 0.005), seq(1.175, 1.8, by=0.025))
# initialize result variables
l=length(targets)
alloc_btc = zeros(l,N_assets)
colnames(alloc_btc)=colnames(my_returns[,2*(1:N_assets)])
sigma_ret_btc = zeros(l,1)
alloc_no_btc = zeros(l,N_assets)
colnames(alloc_no_btc)=colnames(my_returns[,2*(1:N_assets)])
sigma_ret_no_btc = zeros(l,1)
for(i in 1:l){
# print(paste(i, targets[i]))
alloc_btc[i,]= OptimalAllocation(r=expected_return_sample,S=SS, target_return = targets[i], no_short_sales = 1:N_assets)
sigma_ret_btc[i,1] = sqrt( t(alloc_btc[i,]) %*% SS %*%  alloc_btc[i,])
alloc_no_btc[i,2:N_assets]= OptimalAllocation(r=expected_return_sample[2:N_assets], S=SS[2:N_assets,2:N_assets], target_return = targets[i], no_short_sales = 1:(N_assets-1))
sigma_ret_no_btc[i,1] = sqrt( t(alloc_no_btc[i,]) %*% SS %*%  alloc_no_btc[i,])
}
# polish data for small allocation ( allocation of 1e-10 set to zero)
alloc_btc[which(abs(alloc_btc)<1e-10)] = 0
alloc_no_btc[which(abs(alloc_no_btc)<1e-10)] = 0
# aggregate results for saving to file
res2_btc = cbind(targets-1,sigma_ret_btc, alloc_btc)
colnames(res2_btc)[c(1,2)] = c("exp_return","volatility")
res2_no_btc = cbind(targets-1,sigma_ret_no_btc, alloc_no_btc)
colnames(res2_no_btc)[c(1,2)] = c("exp_return","volatility")
# save to file
write.csv(file = "allocation_on_ret.csv", x = res2_btc)
write.csv(file = "allocation_on_ret_no_btc.csv", x = res2_no_btc)
################## Plotting Allocations with R #######################
# ggplot2 library
library(ggplot2)
library(RColorBrewer)
Asset = rep(colnames(alloc_btc), l)
Return = rep(targets, each = N_assets)
Values = drop(matrix(t(alloc_btc), nrow = 1))
colorRampPalette(brewer.pal(9, "Spectral"))(N_assets)
data <- data.frame(Asset,Return,Values)
ggplot(data, aes(x=Return, y=Values, fill=Asset)) +
geom_area(alpha=1 , size=1, colour="black") +
ggtitle("Markowitz Optimal Allocation Without Shortsellling")+
scale_fill_manual(values =colorRampPalette(brewer.pal(9, "Paired"))(N_assets) )
# wiithout btc
maxN = 26
reduced = alloc_no_btc[1:maxN,]
Asset = rep(colnames(reduced), maxN)
Return = rep(targets[1:maxN], each = N_assets)
Values = drop(matrix(t(reduced), nrow = 1))
colorRampPalette(brewer.pal(9, "Spectral"))(N_assets)
data <- data.frame(Asset,Return,Values)
ggplot(data, aes(x=Return, y=Values, fill=Asset)) +
geom_area(alpha=1 , size=1, colour="black") +
ggtitle("Markowitz Optimal Allocation Without Bitcoin")+
scale_fill_manual(values =colorRampPalette(brewer.pal(9, "Paired"))(N_assets) )
n = dim(my_returns)[2]/2
nomi = colnames(my_returns[1:N_samples,2*(1:n)])[colnames(my_returns[1:N_samples,2*(1:n)]) != 'vix']
nomi
nomi
colnames(my_returns[1:N_samples,2*(1:n)])[colnames(my_returns[1:N_samples,2*(1:n)]) != 'vix']
a
a=2
a
)
setwd("C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code")
load("my_returns_final.rda")
load("my_data_final.rda")
setwd("C:/Users/matte/Desktop/MasterThesis-vianello/R_code")
source("MarkowitzMeanVariancePortfolio.R")
my_returns = my_returns_final
my_data = my_data_final
##########################################
##### compute efficient frontier #########
##########################################
library(pracma)
# attach(my_returns)
source("MarkowitzMeanVariancePortfolio.R")
# Number of samples to consider from latest {max is dim(my_returns)[1]}
N_samples = dim(my_returns)[1]
n = dim(my_returns)[2]/2
nomi = colnames(my_returns[1:N_samples,2*(1:n)])[colnames(my_returns[1:N_samples,2*(1:n)]) != 'vix']
nomi
nomi = colnames(my_returns[1:N_samples,2*(1:n)])[colnames(my_returns[1:N_samples,2*(1:n)]) != 'vix'][colnames(my_returns[1:N_samples,2*(1:n)]) != 'xrp']
nomi
setwd("C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code")
load("my_returns_final.rda")
load("my_data_final.rda")
setwd("C:/Users/matte/Desktop/MasterThesis-vianello/R_code")
source("MarkowitzMeanVariancePortfolio.R")
my_returns = my_returns_final
my_data = my_data_final
##########################################
##### compute efficient frontier #########
##########################################
library(pracma)
# attach(my_returns)
source("MarkowitzMeanVariancePortfolio.R")
# Number of samples to consider from latest {max is dim(my_returns)[1]}
N_samples = dim(my_returns)[1]
n = dim(my_returns)[2]/2
nomi = colnames(my_returns[1:N_samples,2*(1:n)])[colnames(my_returns[1:N_samples,2*(1:n)]) != 'vix'][colnames(my_returns[1:N_samples,2*(1:n)]) != 'xrp']
nomi
n = dim(my_returns)[2]/2
nomi_all = colnames(my_returns[1:N_samples,2*(1:n)])
nomi = nomi_all[nomi_all != 'vix' & nomi_all!= 'xrp']
nomi
N_assets = dim(my_returns[nomi]) # -1 to exclude VIX from our analysis
N_assets
# ***** PERCENTAGE RETURNS ******
expected_return_sample = colMeans(exp(my_returns[1:N_samples,nomi]))^255
expected_return_sample
SS = cov(exp(my_returns[1:N_samples,nomi]))*255
max_r = 1.5
y_lim = c(1.00,max_r)
# Plots the efficient frontiers, w/ and w/o Bitcoin, w/ and w/o shortselling
eff_front = PlotEfficientFrontier(expected_return_sample, SS, min_r = 1, max_r=max_r,
exclude_btc = T, add_no_short_sell = T, full_plot = F)
n = dim(my_returns)[2]/2
nomi_all = colnames(my_returns[1:N_samples,2*(1:n)])
nomi = nomi_all[nomi_all != 'vix' & nomi_all!= 'xrp' & nomi_all!= 'eth' & nomi_all!= 'ltc']
N_assets = dim(my_returns[nomi]) # -1 to exclude VIX from our analysis
# ***** PERCENTAGE RETURNS ******
expected_return_sample = colMeans(exp(my_returns[1:N_samples,nomi]))^255
expected_return_sample
SS = cov(exp(my_returns[1:N_samples,nomi]))*255
max_r = 1.5
y_lim = c(1.00,max_r)
# Plots the efficient frontiers, w/ and w/o Bitcoin, w/ and w/o shortselling
eff_front = PlotEfficientFrontier(expected_return_sample, SS, min_r = 1, max_r=max_r,
exclude_btc = T, add_no_short_sell = T, full_plot = F)
nomi = nomi_all[nomi_all != 'vix' & nomi_all!= 'xrp' & nomi_all!= 'eth']
N_assets = dim(my_returns[nomi]) # -1 to exclude VIX from our analysis
# ***** PERCENTAGE RETURNS ******
expected_return_sample = colMeans(exp(my_returns[1:N_samples,nomi]))^255
expected_return_sample
# ***** PERCENTAGE RETURNS ******
expected_return_sample = colMeans(exp(my_returns[1:N_samples,nomi]))^255
SS = cov(exp(my_returns[1:N_samples,nomi]))*255
max_r = 1.5
y_lim = c(1.00,max_r)
# Plots the efficient frontiers, w/ and w/o Bitcoin, w/ and w/o shortselling
eff_front = PlotEfficientFrontier(expected_return_sample, SS, min_r = 1, max_r=max_r,
exclude_btc = T, add_no_short_sell = T, full_plot = F)
setwd("C:/Users/matte/Desktop/MasterThesis-vianello/R_code")
library(mondate)
setwd("C:/Users/matte/Desktop/MasterThesis-vianello/R_code")
load("crypto_data.rda")
load("crypto_returns_w.rda")
setwd("C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code")
load("crypto_data.rda")
load("crypto_returns_w.rda")
load("crypto_returns.rda")
dates = as.Date(btc_date, origin="1899-12-30")
earliest = "2018-01-01"
# latest = max(dates)
latest = "2020-02-02"
w = 46 # rolling window in months
step = 1 # moving step in months
d = as.Date(mondate(latest, timeunits = )-step,origin="1899-12-30")
beg_times = as.Date(mondate(latest)-w)
end_times = latest
beg_times = earliest
n_assets = (dim(my_returns_final)[2]%/%2)
attach(crypto_returns)
dates = as.Date(btc_date, origin="1899-12-30")
earliest = "2018-01-01"
# latest = max(dates)
latest = "2020-02-02"
w = 46 # rolling window in months
step = 1 # moving step in months
d = as.Date(mondate(latest, timeunits = )-step,origin="1899-12-30")
beg_times = as.Date(mondate(latest)-w)
end_times = latest
beg_times = earliest
idx = which(dates >= beg_times & dates<=end_times)
n_assets = (dim(crypto_returns)[2]%/%2)
corr_tot = cor(crypto_returns[idx,2*(1:n_assets)])*100
View(corr_tot)
# target volatility for which allocation will be computed
vol_target = seq(from = 0.0275,to = 0.12, by = 0.0025)
# initialize result variables
allocations_vol = zeros(length(vol_target), N_assets)
length(vol_target)
N_assets
# initialize result variables
allocations_vol = zeros(length(vol_target), n)
colnames(allocations_vol) = colnames(my_returns[,nomi])
