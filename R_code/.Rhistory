library(readxl)
require(rugarch)
library(ggplot2)
require(graphics)
library("dplyr")
library("ggpubr")
btc <- na.omit(read.csv("C:/Users/matte/Desktop/Master-Thesis/R_code/BTC-USD.csv"))
btc <- na.omit(read.csv("C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/BTC-USD.csv"))
spx  <- na.omit(read.csv("C:/Users/matte/Desktop/Master-Thesis/Master-Thesis/R_code/spx.csv"))
btc$returns = c(0,diff(as.matrix(log(prices['Close'])), lag =1)*100)
spx$returns = c(0,diff(as.matrix(log(spx['Close'])), lag =1)*100)
btc$returns = c(0,diff(as.matrix(log(btc['Close'])), lag =1)*100)
spx$returns = c(0,diff(as.matrix(log(spx['Close'])), lag =1)*100)
# qqplot btc
qqnorm(btc$returns)
qqline(btc$returns, col='red')
acf(btc$returns, lag.max = NULL,
type = c("correlation", "covariance", "partial"),
plot = TRUE, na.action = na.fail, demean = TRUE)
btc$square_res = c(btc$returns**2)
View(btc)
View(btc)
2**2
3**3
# qqplot residuals squares
qqnorm(btc$square_res)
qqline(btc$square_res, col='red')
# BTC returns
plot(btc$returns)
# BTC returns
ggplot(data = btc$returns, aes(x = btc$Date, y = btc$returns))
# BTC returns
ggplot(data = btc, aes(x = btc$Date, y = btc$returns))
View(btc)
View(btc)
btc$returns.max
max(btc$returns)
min(btc$returns)
# BTC returns
ggplot(data = btc, aes(x = btc$Date, y = btc$returns))
# BTC returns
ggplot(data = btc, aes(x = btc$Date, y = btc$Close))
plot(btc$Date,btc$Close)
plot(btc$Date,btc$returns)
theme_set(theme_minimal())
# BTC returns
ggplot(data = btc, aes(x = btc$Date, y = btc$Close))
head(btc)
# BTC returns
ggplot(data = btc, aes(x = Date, y = Close))
ggplot(data = btc, aes(x = Date, y = Close))+
geom_line(color = "#00AFBB", size = 2)
# BTC returns
ggplot(data = spx, aes(x = Date, y = Close))
# BTC returns
ggplot(data = spx)
df$date = btc$Date
df$ret = btc$returns
View(df)
View(df)
df = data.frame()
df$date = btc$Date
df$date = c(btc$Date)
df = data.frame(c(btc$Date))
df$ret = c(btc$returns)
# BTC returns
ggplot(data = df)
# BTC returns
ggplot(data = df, aes(x=Date,y=ret))
# BTC returns
ggplot(data = df, aes(x=df$Date,y=df$ret))
# BTC returns
ggplot(data = df, aes(df$Date,df$ret))
View(df)
View(df)
# BTC returns
ggplot(data = df, mapping = aes(df$Date,df$ret))
# BTC returns
ggplot(data = df, mapping = aes(x = Date,y = ret))
# BTC returns
ggplot(data = df, mapping = aes(x = Date, y = ret))
View(df)
View(df)
View(df)
# BTC returns
ggplot(data = df, mapping = aes(x = c.btc.Date., y = ret))
View(df)
df$ret = c(btc$Close)
# BTC returns
ggplot(data = df, mapping = aes(x = c.btc.Date., y = ret))
ggplot(data = df, mapping = aes(x = c.btc.Date., y = ret))+
geom_point()
ggplot(data = btc, mapping = aes(x = Date, y = returns))+
geom_point()
ggplot(data = btc, mapping = aes(x = Date, y = returns))+
geom_line()
ggplot(data = btc, mapping = aes(x = Date, y = returns))+
geom_line()
ggplot(data = spx, mapping = aes(x = Date, y = returns))+
geom_line()
ggplot(data = spx, mapping = aes(x = Date, y = returns))+
geom_line()
spx$returns = c(0,diff(as.matrix(log(spx['Close'])), lag =1)*100)
ggplot(data = spx, mapping = aes(x = Date, y = returns))+
geom_line()
View(spx)
View(spx)
ggplot(data = spx, mapping = aes(x = Date, y = returns))+
geom_point()
# BTC returns
ggplot(data = btc, mapping = aes(x = Date, y = returns))+geom_bar(aes(fill=time))
# BTC returns
ggplot(data = btc, mapping = aes(x = Date, y = returns))+geom_bar(aes(fill=Date))
# BTC returns
ggplot(data = btc, mapping = aes(x = Date, y = returns)) + geom_bar(aes(fill=Date))
# BTC returns
ggplot(data = btc, mapping = aes(x = Date, y = returns)) + geom_bar()
# BTC returns
ggplot(data = btc, mapping = aes(x = Date, y = returns)) + geom_point()
# BTC returns
ggplot(data = btc, mapping = aes(x = Date, y = returns)) + geom_path()
# BTC returns
ggplot(data = btc, mapping = aes(x = Date, y = returns)) + geom_linerange()
# BTC returns
ggplot(data = btc, mapping = aes(x = Date, y = returns)) + geom_line()
# BTC returns
ggplot(data = btc, mapping = aes(x = Date, y = returns)) + geom_abline()
# BTC returns
ggplot(data = btc, mapping = aes(x = Date, y = returns)) + geom_line()
# BTC returns
ggplot(data = btc, mapping = aes(x = Date, y = returns)) + geom_point()
ggplot(data = btc, mapping = aes(x = Date, y = returns)) +
geom_point() +
ggtitle(BTC returns)
ggplot(data = btc, mapping = aes(x = Date, y = returns)) +
geom_point() +
ggtitle('BTC returns')
ggplot(data = btc, mapping = aes(x = Date, y = returns)) +
geom_point() +
ggtitle('BTC returns') +
stat_smooth(
color = "#FC4E07", fill = "#FC4E07",
method = "loess"
)
ggplot(data = btc, mapping = aes(x = Date, y = returns)) +
geom_line(color = "#00AFBB", size = 1) +
ggtitle('BTC returns') +
stat_smooth(
color = "#FC4E07", fill = "#FC4E07",
method = "loess"
)
ggplot(data = btc, mapping = aes(x = Date, y = returns)) +
geom_line(color = "#00AFBB", size = 1) +
ggtitle('BTC returns')
ggplot(data = btc, mapping = aes(x = Date, y = returns)) +
geom_line(color = "#FC4E07", size = 2) +
ggtitle('BTC returns')
ggplot(data = btc, mapping = aes(x = Date, y = returns, group=1)) +
geom_line(color = "#FC4E07", size = 2) +
ggtitle('BTC returns')
ggplot(data = btc, mapping = aes(x = Date, y = returns, group=1)) +
geom_line(color = "#00AFBB", size = 1) +
ggtitle('BTC returns')
ggplot(data = btc, mapping = aes(x = Date, y = returns, group=1)) +
geom_line(color = "#00AFBB", size = 1) +
ggtitle('BTC returns') +
scale_x_continuous(breaks=seq(1900, 2000, 10))
ggplot(data = btc, mapping = aes(x = Date, y = returns, group=1)) +
geom_line(color = "#00AFBB", size = 1) +
ggtitle('BTC returns') +
scale_x_date(name = 'My date axis title', date_breaks = '20 years',
date_labels = '%Y')
ggplot(data = btc, mapping = aes(x = Date, y = returns, group=1)) +
geom_line(color = "#00AFBB", size = 1) +
ggtitle('BTC returns') +
scale_x_date(date_breaks = '20 years', date_labels = '%Y')
ggplot(data = btc, mapping = aes(x = Date, y = returns, group=1)) +
geom_line(color = "#00AFBB", size = 1) +
ggtitle('BTC returns') +
scale_x_date(date_labels = '%Y')
ggplot(data = btc, mapping = aes(x = Date, y = returns, group=1)) +
geom_line(color = "#00AFBB", size = 1) +
ggtitle('BTC returns') +
scale_x_date(breaks=seq(2010, 2019, 10))
ggplot(data = btc, mapping = aes(x = Date, y = returns, group=1)) +
geom_line(color = "#00AFBB", size = 1) +
ggtitle('BTC returns')
ggplot(data = btc, mapping = aes(x = Date, y = returns, group=1)) +
geom_line(color = "#00AFBB", size = 1) +
ggtitle('BTC returns') +
scale_x_date(labels = date_format("%m-%Y"))
str(btc$Date)
View(btc)
btc$Date = as.Date(btc$Date)
ggplot(data = btc, mapping = aes(x = Date, y = returns, group=1)) +
geom_line(color = "#00AFBB", size = 1) +
ggtitle('BTC returns') +
scale_x_date(labels = date_format("%m-%Y"))
ggplot(data = btc, mapping = aes(x = Date, y = returns, group=1)) +
geom_line(color = "#00AFBB", size = 1) +
ggtitle('BTC returns')
p <- qacf(btc$returns, show.sig = TRUE)
install.packages(qwraps2)
install.packages(qwraps)
acf(btc$square_res, lag.max = NULL,
type = c("correlation", "covariance", "partial"),
plot = TRUE, na.action = na.fail, demean = TRUE)
install.packages("forecast")
library(forecast)
### Lag Plot ###
gglagplot(btc$returns)
### Lag Plot ###
gglagchull(btc$returns)
# qqplot residuals squares
qqnorm(btc$square_res)
qqline(btc$square_res, col='red')
# qqplot residuals squares
qqnorm(btc$square_res)
qqline(btc$square_res, col='red')
hist(btc$returns)
hist(btc$returns, breaks = 100)
curve(dnorm(x,mean=mean(btc$returns), std = std(btc$returns)), add=TRUE)
sqrt(var(btc$returns))
curve(dnorm(x,mean=mean(btc$returns), std = sqrt(var(btc$returns))), add=TRUE)
varia = sqrt(var(btc$returns))
m = mean(btc$returns)
varia
m
curve(dnorm(x,mean=m, std = varia), add=TRUE)
curve(dnorm(x,mean=m, sd = varia), add=TRUE)
hist(btc$returns, breaks = 100, density = 2)
curve(dnorm(x,mean=m, sd = varia), add=TRUE)
hist(btc$returns, breaks = 100, density = 2)
curve(dnorm(x,mean=m, sd = varia), add=TRUE)
density(btc$returns)
curve(dnorm(x,mean=m, sd = varia), add=TRUE)
density(btc$returns)
acf(abs(btc$returns), lag.max = NULL,
type = c("correlation", "covariance", "partial"),
plot = TRUE, na.action = na.fail, demean = TRUE)
### Ljung-Box test ###
lag.length = 25
Box.test(btc$returns, lag=lag.length, type="Ljung-Box") # test stationary signal
